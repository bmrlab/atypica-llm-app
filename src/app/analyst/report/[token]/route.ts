import { fetchAnalystReportByToken } from "@/data";
import { prisma } from "@/lib/prisma";
import { notFound, redirect } from "next/navigation";
import { decryptAnalystId } from "../encrypt";

export async function GET(request: Request, { params }: { params: Promise<{ token: string }> }) {
  const token = (await params).token;
  const url = new URL(request.url);
  const isLive = url.searchParams.get("live") === "1";

  if (token.length !== 16) {
    // @TODO[LEGACY] report url generated by analyst/[id]/live page
    const analystId = await decryptAnalystId(token);
    const report = await prisma.analystReport.findFirst({
      where: { analystId },
      orderBy: { createdAt: "asc" },
    });
    if (!report) notFound();
    redirect(`/analyst/report/${report.token}`);
  }

  // Handle live streaming mode
  if (isLive) {
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        let start = 0;
        while (true) {
          try {
            const analystReport = await fetchAnalystReportByToken(token);
            const chunk = analystReport.onePageHtml.substring(start);
            controller.enqueue(encoder.encode(chunk));
            start = analystReport.onePageHtml.length;
            // If report is complete (has a generatedAt timestamp), end the stream
            if (analystReport.generatedAt) {
              controller.close();
              break;
            }
            // Wait for 3 seconds before fetching again
            await new Promise((resolve) => setTimeout(resolve, 3000));
          } catch (error) {
            console.error("Error streaming report:", error);
            controller.error(error);
            break;
          }
        }
      },
    });
    return new Response(stream, {
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Transfer-Encoding": "chunked",
        "Cache-Control": "no-cache",
      },
    });
  }

  // Regular non-streaming response
  const analystReport = await fetchAnalystReportByToken(token);
  return new Response(analystReport.onePageHtml, {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
    },
  });
}
